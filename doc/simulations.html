<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title>Simulations</title>
<style type="text/css">
body {
  font-family: sans-serif;
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 1.5;
  print-color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
body, .abstract, code, .footnotes, footer, #refs, .caption { font-size: .9em; }
li li { font-size: .95em; }
ul:has(li > input[type="checkbox"]) { list-style: none; padding-left: 1em; }
*, :before, :after { box-sizing: border-box; }
a { color: steelblue; }
pre, img { max-width: 100%; }
pre { white-space: pre-wrap; word-break: break-word; }
pre code { display: block; padding: 1em; overflow-x: auto; }
code { font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace; }
:not(pre, th) > code, code[class], div > .caption { background: #f8f8f8; }
pre > code:is(:not([class]), .language-plain, .language-none, .plain), .box, .figure, .table { background: inherit; border: 1px solid #eee; }
pre > code {
  &.message { border-color: #9eeaf9; }
  &.warning { background: #fff3cd; border-color: #fff3cd; }
  &.error { background: #f8d7da; border-color: #f8d7da; }
}
.fenced-chunk { border-left: 1px solid #666; }
.code-fence {
  opacity: .4;
  border: 1px dashed #666;
  border-left: 2px solid;
  &:hover { opacity: inherit; }
}
.box, .figure, .table, table { margin: 1em auto; }
div > .caption { padding: 1px 1em; }
.figure { p:has(img, svg), pre:has(svg) { text-align: center; } }
.flex-col { display: flex; justify-content: space-between; }
table {
  &:only-child:not(.table > *) { margin: auto; }
  th, td { padding: 5px; font-variant-numeric: tabular-nums; }
  thead, tfoot, tr:nth-child(even) { background: whitesmoke; }
  thead th { border-bottom: 1px solid #ddd; }
  &:not(.datatable-table) {
    border-top: 1px solid #666;
    border-bottom: 1px solid #666;
  }
}
blockquote {
  color: #666;
  margin: 0;
  padding: 1px 1em;
  border-left: .5em solid #eee;
}
hr, .footnotes::before { border: 1px dashed #ddd; }
.frontmatter { text-align: center; }
#TOC {
  a { text-decoration: none; }
  ul { list-style: none; padding-left: 1em; }
  & > ul { padding: 0; }
  ul ul { border-left: 1px solid lightsteelblue; }
}
.body h2 { border-bottom: 1px solid #666; }
.body .appendix, .appendix ~ h2 { border-bottom-style: dashed; }
.main-number::after { content: "."; }
span[class^="ref-number-"] { font-weight: bold; }
.ref-number-fig::after, .ref-number-tab::after { content: ":"; }
.cross-ref-chp::before { content: "Chapter "; }
.cross-ref-sec::before { content: "Section "; }
.cross-ref-fig::before, .ref-number-fig::before { content: "Figure "; }
.cross-ref-tab::before, .ref-number-tab::before { content: "Table "; }
.cross-ref-eqn::before, .MathJax_ref:has(mjx-mtext > mjx-c + mjx-c)::before { content: "Equation "; }
.abstract, #refs {
  &::before { display: block; margin: 1em auto; font-weight: bold; }
}
.abstract::before { content: "Abstract"; text-align: center; }
#refs::before { content: "Bibliography"; font-size: 1.5em; }
.ref-paren-open::before { content: "("; }
.ref-paren-close::after { content: ")"; }
.ref-semicolon::after { content: "; "; }
.ref-and::after { content: " and "; }
.ref-et-al::after { content: " et al."; font-style: italic; }
.footnote-ref a {
  &::before { content: "["; }
  &::after { content: "]"; }
}
section.footnotes {
  margin-top: 2em;
  &::before { content: ""; display: block; max-width: 20em; }
}
.fade {
  background: repeating-linear-gradient(135deg, white, white 30px, #ddd 32px, #ddd 32px);
  opacity: 0.6;
}

@media print {
  body { max-width: 100%; }
  tr, img { break-inside: avoid; }
}
@media only screen and (min-width: 992px) {
  body:not(.pagesjs) pre:has(.line-numbers):not(:hover) { white-space: pre; }
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/combine/npm/katex@0.16.22/dist/katex.min.js,npm/katex@0.16.22/dist/contrib/auto-render.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/js/render-katex.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>Simulations</h1></div>
</div>
<div class="body">
<h2 id="sec:introduction">Introduction</h2>
<p>We consider the following models with \(\mathbf{X}=\left(X_1, \ldots, X_p\right) \sim N\left(0, I_p\right) \in \mathbb{R}^p\) :</p>
<ul>
<li>
<p><strong>LM</strong> (linear model in <em>Deb et al., 2022</em>):<br />
$$
Y = 3 X_1 + 2 X_2 - X_3 + N(0,1).
$$</p>
</li>
<li>
<p><strong>GAM</strong> (generalized additive model in <em>Deb et al., 2022</em>):<br />
$$
Y = \sin(X_1) + 2 \cos(X_2) + e^{X_3} + N(0,1).
$$</p>
</li>
<li>
<p><strong>Nonlin1</strong> (Nonlinear model in <em>Azadkia &amp; Chatterjee, 2021</em> and <em>Deb et al., 2022</em>):<br />
$$
Y = X_1 X_2 + \sin(X_1 X_3).
$$</p>
</li>
<li>
<p><strong>Nonlin2</strong> (heavy-tailed in <em>Deb et al., 2022</em>):<br />
$$
Y = \frac{2 \log(X_1^2 + X_2^4)}{\cos(X_1) + \sin(X_3)} + \epsilon, \quad \epsilon \sim t_1
$$</p>
</li>
<li>
<p><strong>Nonlin3</strong> (Non-additive noise in <em>Deb et al., 2022</em>):<br />
$$
Y = |X_1 + U|^{\sin(X_2 - X_3)}, \quad U \sim \text{Uniform}[0,1]
$$</p>
</li>
<li>
<p><strong>Shine 1</strong> (Oscillation in middle):<br />
$$
Y = \frac{\sin(X_1)}{X_1} + X_2 X_3
$$</p>
</li>
<li>
<p><strong>Shine 2</strong> (Smooth Oscillation in middle):<br />
$$
Y = \frac{\sin(X_1)}{\sqrt{|X_1|}} + X_2 X_3
$$</p>
</li>
<li>
<p><strong>Shine 3</strong> (Single interactive oscillation in middle):<br />
$$
Y = \frac{\sin(X_1)}{X_2} + X_2 X_3
$$</p>
</li>
<li>
<p><strong>Shine 4</strong> (Multi interactive oscillations in middle):<br />
$$
Y = \frac{\sin(X_1)}{X_3} + \frac{\sin(X_2)}{X_1} + \frac{\sin(X_3)}{X_2}
$$</p>
</li>
</ul>
<h2 id="sec:code-example">Code Example</h2>
<pre><code class="language-r"># Libraries ----
library(parallel)
library(foreach)
library(FOCI)
library(KPC)
library(ford)

# Experiment
it &lt;- 1000
N &lt;- c(100, 500, 1000)
p &lt;- 1000

markov_blanket_size &lt;- 3

for(n in N){
  n.cores &lt;- parallel::detectCores() 
  my.cluster &lt;- parallel::makeCluster(n.cores, type = &quot;PSOCK&quot;)
  doParallel::registerDoParallel(cl = my.cluster)
  
  singleRun &lt;- function() {
    
    X &lt;- matrix(rnorm(n * p), ncol = p)
    Y &lt;-  sin(X[, 1])/((X[, 2])) + X[,2]* X[,3]
    
    
    ford &lt;- ford(Y, X)$selectedVar$index
    foci &lt;- foci(Y, X)$selectedVar$index
    #kfoci &lt;- KFOCI(Y, X)

    
    number_of_selected_var_ford &lt;- length(ford)
    number_of_selected_var_foci &lt;- length(foci)

    
    true_selected_ford &lt;- length(intersect(ford, 1:markov_blanket_size))
    true_selected_foci &lt;- length(intersect(foci, 1:markov_blanket_size))

    false_selected_ford &lt;- length(setdiff(ford, 1:markov_blanket_size))
    false_selected_foci &lt;- length(setdiff(foci, 1:markov_blanket_size))

    flag_1_selected_ford &lt;- 1*(1 %in% ford)
    flag_1_selected_foci &lt;- 1*(1 %in% foci)

    flag_2_selected_ford &lt;- 1*(2 %in% ford)
    flag_2_selected_foci &lt;- 1*(2 %in% foci)

    flag_3_selected_ford &lt;- 1*(3 %in% ford)
    flag_3_selected_foci &lt;- 1*(3 %in% foci)

    
    return(c(number_of_selected_var_ford, number_of_selected_var_foci,
             true_selected_ford, true_selected_foci,
             false_selected_ford, false_selected_foci,
             flag_1_selected_ford, flag_1_selected_foci,
             flag_2_selected_ford, flag_2_selected_foci,
             flag_3_selected_ford, flag_3_selected_foci
             ))
  }
  
  values &lt;- foreach(i = 1:it, .packages = c(&quot;FOCI&quot;, &quot;RANN&quot;, &quot;ford&quot;)) %dopar% {
    singleRun()
  }
  
  print(n)

  saveRDS(object = values, file = paste(&quot;/results/Shine3_MB&quot;, markov_blanket_size,&quot;_n&quot;, n, &quot;_p&quot;, p, &quot;.RDS&quot;, sep = &quot;&quot;))
  parallel::stopCluster(cl = my.cluster)
}
</code></pre>
<h2 id="sec:results_1">Results</h2>
<pre><code class="language-r"># Load all data

getwd()
#&gt; [1] &quot;C:/Users/rouda/OneDrive/Desktop/FORD/vignettes&quot;
file_path &lt;- system.file(&quot;extdata&quot;, &quot;final_simulation_results&quot;, package = &quot;FORD&quot;)

rds_files &lt;- list.files(file_path, pattern = &quot;\\.rds$&quot;, full.names = TRUE)

rds_list &lt;- lapply(rds_files, readRDS)

names(rds_list) &lt;- tools::file_path_sans_ext(basename(rds_files))


# Define a helper function to process each element
process_rds_element &lt;- function(data_list, name) {
  df &lt;- as.data.frame(do.call(rbind, data_list))
  colnames(df) &lt;- c(&quot;number_of_selected_var_FORD&quot;, &quot;number_of_selected_var_FOCI&quot;,
                    &quot;true_selected_FORD&quot;, &quot;true_selected_FOCI&quot;,
                    &quot;false_selected_FORD&quot;, &quot;false_selected_FOCI&quot;,
                    &quot;flag_1_selected_FORD&quot;, &quot;flag_1_selected_FOCI&quot;,
                    &quot;flag_2_selected_FORD&quot;, &quot;flag_2_selected_FOCI&quot;,
                    &quot;flag_3_selected_FORD&quot;, &quot;flag_3_selected_FOCI&quot;)

  df &lt;- df %&gt;% mutate(
    exact_flag_FORD = 1 * (true_selected_FORD == 3 &amp; false_selected_FORD == 0),
    exact_flag_FOCI = 1 * (true_selected_FOCI == 3 &amp; false_selected_FOCI == 0),
    inclusion_flag_FORD = 1 * (true_selected_FORD == 3),
    inclusion_flag_FOCI = 1 * (true_selected_FOCI == 3)
  )

  df_summary &lt;- df %&gt;% summarise(
    exact_flag_FORD = mean(exact_flag_FORD),
    inclusion_flag_FORD = mean(inclusion_flag_FORD),
    number_of_selected_var_FORD = mean(number_of_selected_var_FORD),
    exact_flag_FOCI = mean(exact_flag_FOCI),
    inclusion_flag_FOCI = mean(inclusion_flag_FOCI),
    number_of_selected_var_FOCI = mean(number_of_selected_var_FOCI)
  )

  df_summary$Models &lt;- str_split(name,&quot;_&quot;)[[1]][1]
    
  df_summary$n &lt;- as.numeric(str_remove(str_split(name,&quot;_&quot;)[[1]][3],&quot;n&quot;))
  return(df_summary)
}

# Process all 27 elements
all_results &lt;- purrr::imap_dfr(rds_list, process_rds_element)

# Reorder columns
all_results &lt;- all_results %&gt;%
  select(Models,n, everything()) %&gt;% 
  arrange(Models,n)

# Display as a kable table
kable(all_results, caption = &quot;Summary of Selection Accuracy for Each Simulation Setting&quot;, digits = 3)
</code></pre>
<p>Table: Summary of Selection Accuracy for Each Simulation Setting</p>
<table>
<thead>
<tr>
<th align="left">Models</th>
<th align="right">n</th>
<th align="right">exact_flag_FORD</th>
<th align="right">inclusion_flag_FORD</th>
<th align="right">number_of_selected_var_FORD</th>
<th align="right">exact_flag_FOCI</th>
<th align="right">inclusion_flag_FOCI</th>
<th align="right">number_of_selected_var_FOCI</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">GAM</td>
<td align="right">100</td>
<td align="right">0.000</td>
<td align="right">0.029</td>
<td align="right">4.185</td>
<td align="right">0.000</td>
<td align="right">0.002</td>
<td align="right">4.497</td>
</tr>
<tr>
<td align="left">GAM</td>
<td align="right">500</td>
<td align="right">0.032</td>
<td align="right">0.907</td>
<td align="right">4.098</td>
<td align="right">0.003</td>
<td align="right">0.622</td>
<td align="right">4.651</td>
</tr>
<tr>
<td align="left">GAM</td>
<td align="right">1000</td>
<td align="right">0.079</td>
<td align="right">1.000</td>
<td align="right">3.952</td>
<td align="right">0.008</td>
<td align="right">0.970</td>
<td align="right">4.431</td>
</tr>
<tr>
<td align="left">LM</td>
<td align="right">100</td>
<td align="right">0.030</td>
<td align="right">0.303</td>
<td align="right">3.883</td>
<td align="right">0.003</td>
<td align="right">0.064</td>
<td align="right">4.362</td>
</tr>
<tr>
<td align="left">LM</td>
<td align="right">500</td>
<td align="right">0.526</td>
<td align="right">1.000</td>
<td align="right">3.474</td>
<td align="right">0.103</td>
<td align="right">0.974</td>
<td align="right">3.906</td>
</tr>
<tr>
<td align="left">LM</td>
<td align="right">1000</td>
<td align="right">0.808</td>
<td align="right">1.000</td>
<td align="right">3.192</td>
<td align="right">0.253</td>
<td align="right">1.000</td>
<td align="right">3.748</td>
</tr>
<tr>
<td align="left">Nonlin1</td>
<td align="right">100</td>
<td align="right">0.015</td>
<td align="right">0.063</td>
<td align="right">3.530</td>
<td align="right">0.001</td>
<td align="right">0.015</td>
<td align="right">4.034</td>
</tr>
<tr>
<td align="left">Nonlin1</td>
<td align="right">500</td>
<td align="right">0.228</td>
<td align="right">0.479</td>
<td align="right">2.954</td>
<td align="right">0.061</td>
<td align="right">0.158</td>
<td align="right">2.924</td>
</tr>
<tr>
<td align="left">Nonlin1</td>
<td align="right">1000</td>
<td align="right">0.547</td>
<td align="right">0.824</td>
<td align="right">3.092</td>
<td align="right">0.172</td>
<td align="right">0.347</td>
<td align="right">2.792</td>
</tr>
<tr>
<td align="left">Nonlin2</td>
<td align="right">100</td>
<td align="right">0.000</td>
<td align="right">0.001</td>
<td align="right">3.380</td>
<td align="right">0.000</td>
<td align="right">0.000</td>
<td align="right">4.053</td>
</tr>
<tr>
<td align="left">Nonlin2</td>
<td align="right">500</td>
<td align="right">0.055</td>
<td align="right">0.275</td>
<td align="right">3.149</td>
<td align="right">0.006</td>
<td align="right">0.074</td>
<td align="right">3.086</td>
</tr>
<tr>
<td align="left">Nonlin2</td>
<td align="right">1000</td>
<td align="right">0.328</td>
<td align="right">0.675</td>
<td align="right">3.305</td>
<td align="right">0.139</td>
<td align="right">0.419</td>
<td align="right">3.271</td>
</tr>
<tr>
<td align="left">Nonlin3</td>
<td align="right">100</td>
<td align="right">0.000</td>
<td align="right">0.002</td>
<td align="right">3.271</td>
<td align="right">0.000</td>
<td align="right">0.000</td>
<td align="right">4.020</td>
</tr>
<tr>
<td align="left">Nonlin3</td>
<td align="right">500</td>
<td align="right">0.059</td>
<td align="right">0.259</td>
<td align="right">2.883</td>
<td align="right">0.004</td>
<td align="right">0.073</td>
<td align="right">3.076</td>
</tr>
<tr>
<td align="left">Nonlin3</td>
<td align="right">1000</td>
<td align="right">0.245</td>
<td align="right">0.520</td>
<td align="right">2.898</td>
<td align="right">0.042</td>
<td align="right">0.162</td>
<td align="right">2.768</td>
</tr>
<tr>
<td align="left">Shine1</td>
<td align="right">100</td>
<td align="right">0.003</td>
<td align="right">0.014</td>
<td align="right">3.316</td>
<td align="right">0.003</td>
<td align="right">0.008</td>
<td align="right">4.119</td>
</tr>
<tr>
<td align="left">Shine1</td>
<td align="right">500</td>
<td align="right">0.300</td>
<td align="right">0.470</td>
<td align="right">2.916</td>
<td align="right">0.088</td>
<td align="right">0.191</td>
<td align="right">3.406</td>
</tr>
<tr>
<td align="left">Shine1</td>
<td align="right">1000</td>
<td align="right">0.679</td>
<td align="right">0.904</td>
<td align="right">3.139</td>
<td align="right">0.213</td>
<td align="right">0.452</td>
<td align="right">2.996</td>
</tr>
<tr>
<td align="left">Shine2</td>
<td align="right">100</td>
<td align="right">0.028</td>
<td align="right">0.116</td>
<td align="right">3.963</td>
<td align="right">0.001</td>
<td align="right">0.026</td>
<td align="right">4.130</td>
</tr>
<tr>
<td align="left">Shine2</td>
<td align="right">500</td>
<td align="right">0.572</td>
<td align="right">0.802</td>
<td align="right">3.206</td>
<td align="right">0.243</td>
<td align="right">0.382</td>
<td align="right">3.083</td>
</tr>
<tr>
<td align="left">Shine2</td>
<td align="right">1000</td>
<td align="right">0.938</td>
<td align="right">0.992</td>
<td align="right">3.054</td>
<td align="right">0.574</td>
<td align="right">0.752</td>
<td align="right">3.073</td>
</tr>
<tr>
<td align="left">Shine3</td>
<td align="right">100</td>
<td align="right">0.004</td>
<td align="right">0.026</td>
<td align="right">3.230</td>
<td align="right">0.000</td>
<td align="right">0.004</td>
<td align="right">4.104</td>
</tr>
<tr>
<td align="left">Shine3</td>
<td align="right">500</td>
<td align="right">0.418</td>
<td align="right">0.661</td>
<td align="right">3.072</td>
<td align="right">0.038</td>
<td align="right">0.098</td>
<td align="right">3.057</td>
</tr>
<tr>
<td align="left">Shine3</td>
<td align="right">1000</td>
<td align="right">0.809</td>
<td align="right">0.966</td>
<td align="right">3.131</td>
<td align="right">0.117</td>
<td align="right">0.229</td>
<td align="right">2.796</td>
</tr>
<tr>
<td align="left">Shine4</td>
<td align="right">100</td>
<td align="right">0.000</td>
<td align="right">0.000</td>
<td align="right">3.225</td>
<td align="right">0.000</td>
<td align="right">0.000</td>
<td align="right">3.990</td>
</tr>
<tr>
<td align="left">Shine4</td>
<td align="right">500</td>
<td align="right">0.140</td>
<td align="right">0.193</td>
<td align="right">2.703</td>
<td align="right">0.019</td>
<td align="right">0.036</td>
<td align="right">2.869</td>
</tr>
<tr>
<td align="left">Shine4</td>
<td align="right">1000</td>
<td align="right">0.378</td>
<td align="right">0.515</td>
<td align="right">2.789</td>
<td align="right">0.067</td>
<td align="right">0.112</td>
<td align="right">2.784</td>
</tr>
</tbody>
</table>
<h2 id="sec:an-experiment-on-the-running-time">An experiment on the running time:</h2>
<p>In this experiment, we compare the computational complexity of \(\xi_n\) from <a href="https://www.tandfonline.com/doi/full/10.1080/01621459.2020.1758115"><em>A new coefficient of correlation</em>, Chatterjee 2021</a>, \(T_n\) from <a href="https://www.jstor.org/stable/27170947"><em>A Simple Measure Of Conditional Dependence</em></a>, \(\widehat{\rho^2}\) and \(\widetilde{\rho^2}\) from <a href="https://www.jmlr.org/papers/volume23/21-493/21-493.pdf"><em>Kernel Partial Correlation Coefficient</em></a>, with the proposed metrics in this paper: \(\nu_n\) and \(\nu_{n}^{\text{1-dim}}\).</p>
<p>We sampled \(X\) and \(Y\) independently from standard normal distributions and conducted 100 replications. The average computation time for each method was then recorded.</p>
<h3 id="sec:implementation">Implementation</h3>
<pre><code class="language-r"># Libraries ----
library(XICOR)
library(ford)
library(FOCI)
library(KPC)
library(doParallel)
library(foreach)

# Sample sizes ----
sizes &lt;- c(1e1, floor(3.162278 * 10), 1e2, floor(3.162278 * 100),
           1e3, floor(3.162278 * 1000), 1e4)

# Detect and register all available cores
num_cores &lt;- parallel::detectCores()
cl &lt;- makeCluster(num_cores)
registerDoParallel(cl)

# Initialize results list
time_list &lt;- list()

# Loop over sample sizes
for (n in sizes) {
  cat(&quot;Running for n =&quot;, n, &quot;\n&quot;)
  
  res &lt;- foreach(i = 1:100, .combine = rbind, .packages = c(&quot;XICOR&quot;, &quot;ford&quot;, &quot;FOCI&quot;, &quot;KPC&quot;)) %dopar% {
    set.seed(i)
    X &lt;- rnorm(round(n))
    Y &lt;- rnorm(round(n))
    
    # Compute values and elapsed times
    xicor_time &lt;- system.time(xicor(X, Y))[&quot;elapsed&quot;]
    codec_time &lt;- system.time(codec(Y = Y, Z = X))[&quot;elapsed&quot;]
    kpc_graph_time &lt;- system.time(KPCgraph(Y = Y, Z = X, X = NULL))[&quot;elapsed&quot;]
    kpc_rkhs_time &lt;- system.time( KPCRKHS(Y = Y, Z = X, X = NULL))[&quot;elapsed&quot;]
    irdc_time &lt;- system.time( irdc(Y, X))[&quot;elapsed&quot;]
    irdc_simple_time &lt;- system.time( irdc_simple(Y, X))[&quot;elapsed&quot;]
    
    # Return results as data.frame
    data.frame(
      n = n,
      xicor_time = xicor_time,
      codec_time = codec_time,
      kpc_graph_time = kpc_graph_time,
      kpc_rkhs_time = kpc_rkhs_time,
      irdc_time = irdc_time,
      irdc_simple_time = irdc_simple_time
    )
  }
  
  time_list[[as.character(n)]] &lt;- res
}

# Stop the parallel cluster
stopCluster(cl)

# Save results
saveRDS(time_list, &quot;/results/method_timings_by_size.rds&quot;)
</code></pre>
<h2 id="sec:results_2">Results</h2>
<pre><code class="language-r">file_path &lt;- system.file(&quot;extdata&quot;, &quot;method_timings_by_size.rds&quot;, package = &quot;FORD&quot;)
method_timings_by_size &lt;- readRDS(file_path)

# Initialize result list
summary_list &lt;- lapply(names(method_timings_by_size), function(n_val) {
  df &lt;- method_timings_by_size[[n_val]]
  means &lt;- colMeans(df)
  data.frame(n = as.numeric(n_val), t(means))
})

# Combine into a single dataframe
summary_df &lt;- do.call(rbind, summary_list)
summary_df &lt;- summary_df %&gt;% select(-n.1)

# Display as a kable table
kable(summary_df, caption = &quot;Summary of Simulation Time for different methods&quot;)
</code></pre>
<p>Table: Summary of Simulation Time for different methods</p>
<table>
<thead>
<tr>
<th align="right">n</th>
<th align="right">xicor_time</th>
<th align="right">codec_time</th>
<th align="right">kpc_graph_time</th>
<th align="right">kpc_rkhs_time</th>
<th align="right">irdc_time</th>
<th align="right">irdc_simple_time</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">10</td>
<td align="right">0.00092</td>
<td align="right">0.01092</td>
<td align="right">0.01468</td>
<td align="right">0.01036</td>
<td align="right">0.00098</td>
<td align="right">0.00035</td>
</tr>
<tr>
<td align="right">31</td>
<td align="right">0.00059</td>
<td align="right">0.00323</td>
<td align="right">0.01046</td>
<td align="right">0.00982</td>
<td align="right">0.00133</td>
<td align="right">0.00039</td>
</tr>
<tr>
<td align="right">100</td>
<td align="right">0.00069</td>
<td align="right">0.00417</td>
<td align="right">0.01886</td>
<td align="right">0.01558</td>
<td align="right">0.00311</td>
<td align="right">0.00044</td>
</tr>
<tr>
<td align="right">316</td>
<td align="right">0.00079</td>
<td align="right">0.00734</td>
<td align="right">0.05568</td>
<td align="right">0.11863</td>
<td align="right">0.00866</td>
<td align="right">0.00049</td>
</tr>
<tr>
<td align="right">1000</td>
<td align="right">0.00114</td>
<td align="right">0.01684</td>
<td align="right">0.33250</td>
<td align="right">3.03182</td>
<td align="right">0.02761</td>
<td align="right">0.00076</td>
</tr>
<tr>
<td align="right">3162</td>
<td align="right">0.00247</td>
<td align="right">0.04560</td>
<td align="right">3.11779</td>
<td align="right">88.56498</td>
<td align="right">0.11807</td>
<td align="right">0.00176</td>
</tr>
<tr>
<td align="right">10000</td>
<td align="right">0.00731</td>
<td align="right">0.14825</td>
<td align="right">34.68341</td>
<td align="right">2604.97461</td>
<td align="right">0.68661</td>
<td align="right">0.00485</td>
</tr>
</tbody>
</table>
<pre><code class="language-r">
# Pivot to long format
long_time_df &lt;- summary_df %&gt;%
  pivot_longer(
    cols = -n,
    names_to = &quot;method&quot;,
    values_to = &quot;time&quot;
  )

# View the result
#print(long_time_df)


# Step 1: Create reference complexity lines
n_vals &lt;- unique(long_time_df$n)
ref_df &lt;- tibble(
  n = n_vals,
  `n log n` = n_vals * log(n_vals),
  `n^2` = n_vals^2
) %&gt;%
  mutate(
    `n log n` = 1e-6 * `n log n`,
    `n^2` = 1e-8 * `n^2`
  ) %&gt;%
  pivot_longer(cols = c(`n log n`, `n^2`), names_to = &quot;method&quot;, values_to = &quot;time&quot;)

# Step 2: Bind with actual data
combined_df &lt;- bind_rows(long_time_df, ref_df)

# Step 3: Define manual aesthetics
color_manual &lt;- c(
  &quot;n log n&quot; = &quot;gray50&quot;,
  &quot;n^2&quot; = &quot;black&quot;
)
linetype_manual &lt;- c(
  &quot;n log n&quot; = &quot;dashed&quot;,
  &quot;n^2&quot; = &quot;dotted&quot;
)

# Set solid line for other methods
methods &lt;- unique(long_time_df$method)
for (m in methods) {
  color_manual[m] &lt;- scales::hue_pal()(length(methods))[which(methods == m)]
  linetype_manual[m] &lt;- &quot;solid&quot;
}

# Step 4: Plot
ggplot(combined_df, aes(x = n, y = time, color = method, linetype = method)) +
  geom_line(linewidth = 1) +
  geom_point(data = filter(long_time_df, !method %in% c(&quot;n log n&quot;, &quot;n^2&quot;))) +
  scale_x_log10() +
  scale_y_log10() +
  scale_color_manual(values = color_manual) +
  scale_linetype_manual(values = linetype_manual) +
  theme_bw() +
  labs(x = &quot;n&quot;, y = &quot;Time&quot;)
</code></pre>
<p><img src="data:image/png;base64,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" alt="plot of chunk timings" /></p>
<p>As shown in the table and plot, the most efficient methods in terms of time complexity are \(\nu_n^{\text{1-dim}}\) and \(\xi_n\), both exhibiting \(O(n \log n)\) behavior. The statistics \(\nu_n\) and \(T_n\) also operate with \(O(n \log n)\) complexity. In contrast, the kernel-based measures \(\widehat{\rho^2}\) and \(\widetilde{\rho^2}\) are significantly more computationally expensive, with a time complexity of \(O(n^2)\).</p>
</div>
</body>
</html>
